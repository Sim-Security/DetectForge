/**
 * Unit tests for the ATT&CK Navigator layer reporter.
 *
 * Tests: generateNavigatorLayer, writeNavigatorLayer
 *
 * Note: The source file (src/reporting/attack-navigator.ts) is being written
 * concurrently by another agent. These tests target the expected interface.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { writeFileSync, mkdirSync } from 'fs';
import {
  generateNavigatorLayer,
  writeNavigatorLayer,
} from '@/reporting/attack-navigator.js';
import {
  calculateCoverageMetrics,
  exportNavigatorLayer,
} from '@/testing/coverage-metrics.js';
import type { GeneratedRule } from '@/types/detection-rule.js';
import type {
  ExtractedIOC,
  ExtractedTTP,
  AttackMappingResult,
} from '@/types/extraction.js';

// ---------------------------------------------------------------------------
// Mocks
// ---------------------------------------------------------------------------

vi.mock('fs', async () => {
  const actual = await vi.importActual('fs');
  return {
    ...actual,
    writeFileSync: vi.fn(),
    mkdirSync: vi.fn(),
  };
});

vi.mock('@/testing/coverage-metrics.js', () => ({
  calculateCoverageMetrics: vi.fn(),
  exportNavigatorLayer: vi.fn(),
}));

// ---------------------------------------------------------------------------
// Fixture Builders
// ---------------------------------------------------------------------------

function makeTTP(overrides?: Partial<ExtractedTTP>): ExtractedTTP {
  return {
    description: 'PowerShell download cradle execution',
    tools: ['PowerShell'],
    targetPlatforms: ['windows'],
    artifacts: [{ type: 'process', description: 'powershell.exe spawned' }],
    detectionOpportunities: ['Monitor process creation'],
    confidence: 'high',
    ...overrides,
  };
}

function makeMapping(overrides?: Partial<AttackMappingResult>): AttackMappingResult {
  return {
    techniqueId: 'T1059.001',
    techniqueName: 'PowerShell',
    tactic: 'execution',
    confidence: 'high',
    reasoning: 'Uses PowerShell',
    sourceTtp: makeTTP(),
    suggestedRuleFormats: ['sigma'],
    validated: true,
    ...overrides,
  };
}

function makeRule(overrides?: Partial<GeneratedRule>): GeneratedRule {
  return {
    format: 'sigma',
    sigma: {
      id: 'abc-123',
      title: 'Suspicious PowerShell Download Cradle',
      status: 'experimental',
      description: 'Detects PowerShell download cradle.',
      references: [],
      author: 'DetectForge',
      date: '2026-02-10',
      modified: '2026-02-10',
      tags: ['attack.execution', 'attack.t1059.001'],
      logsource: { product: 'windows', category: 'process_creation' },
      detection: { selection: { Image: ['*\\powershell.exe'] }, condition: 'selection' },
      falsepositives: ['Admin scripts'],
      level: 'high',
      raw: 'title: Suspicious PowerShell Download Cradle',
    },
    sourceReportId: 'report-1',
    attackTechniqueId: 'T1059.001',
    attackTactic: 'execution',
    confidence: 'high',
    validation: { valid: true, syntaxValid: true, schemaValid: true, errors: [], warnings: [] },
    ...overrides,
  };
}

// ---------------------------------------------------------------------------
// Shared mock return values
// ---------------------------------------------------------------------------

const mockCoverageMetrics = {
  totalTechniques: 5,
  coveredTechniques: 2,
  coveragePercentage: 40,
  tacticBreakdown: {
    execution: { covered: 1, total: 2, percentage: 50 },
    persistence: { covered: 1, total: 3, percentage: 33.33 },
  },
  coveredTechniqueIds: ['T1059.001', 'T1053.005'],
  uncoveredTechniqueIds: ['T1547.001', 'T1071.001', 'T1105'],
  navigatorLayer: {
    name: 'DetectForge Coverage Layer',
    versions: { attack: '14', navigator: '4.9.5', layer: '4.5' },
    domain: 'enterprise-attack',
    description: 'Detection coverage: 40% of identified techniques. Generated by DetectForge.',
    techniques: [
      { techniqueID: 'T1059.001', tactic: 'execution', color: '#31a354', comment: 'Covered', enabled: true, score: 100 },
      { techniqueID: 'T1053.005', tactic: 'execution', color: '#31a354', comment: 'Covered', enabled: true, score: 100 },
    ],
  },
};

const mockLayerJson = JSON.stringify(mockCoverageMetrics.navigatorLayer, null, 2);

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

beforeEach(() => {
  vi.clearAllMocks();
  (calculateCoverageMetrics as ReturnType<typeof vi.fn>).mockReturnValue(mockCoverageMetrics);
  (exportNavigatorLayer as ReturnType<typeof vi.fn>).mockReturnValue(mockLayerJson);
});

describe('generateNavigatorLayer', () => {
  it('calls calculateCoverageMetrics with rules and mappings', () => {
    const rules = [makeRule()];
    const mappings = [makeMapping()];
    generateNavigatorLayer(rules, mappings);

    expect(calculateCoverageMetrics).toHaveBeenCalledTimes(1);
    expect(calculateCoverageMetrics).toHaveBeenCalledWith(rules, mappings);
  });

  it('returns a layer derived from the coverage metrics result', () => {
    const rules = [makeRule()];
    const mappings = [makeMapping()];
    const layer = generateNavigatorLayer(rules, mappings);

    // The returned layer should contain data from the coverage metrics
    expect(layer).toBeDefined();
    expect(layer.domain).toBe(mockCoverageMetrics.navigatorLayer.domain);
    expect(layer.techniques).toEqual(mockCoverageMetrics.navigatorLayer.techniques);
  });

  it('returns the layer object from exportNavigatorLayer', () => {
    const rules = [makeRule()];
    const mappings = [makeMapping()];
    const result = generateNavigatorLayer(rules, mappings);

    // exportNavigatorLayer returns a JSON string, so the function should
    // return either the string or the parsed object. We accept either.
    expect(result).toBeDefined();
  });

  it('applies custom layerName option', () => {
    const rules = [makeRule()];
    const mappings = [makeMapping()];

    generateNavigatorLayer(rules, mappings, { layerName: 'Custom Layer' });

    // The function should pass the custom layer name through.
    // We verify it was called and the option was accepted without error.
    expect(calculateCoverageMetrics).toHaveBeenCalledTimes(1);
  });

  it('applies custom description option', () => {
    const rules = [makeRule()];
    const mappings = [makeMapping()];

    generateNavigatorLayer(rules, mappings, { description: 'Custom description for the layer' });

    // Verify the function accepted the option without error
    expect(calculateCoverageMetrics).toHaveBeenCalledTimes(1);
  });
});

describe('writeNavigatorLayer', () => {
  it('writes JSON to file', () => {
    const rules = [makeRule()];
    const mappings = [makeMapping()];

    writeNavigatorLayer(rules, mappings, '/tmp/output/navigator.json');

    expect(writeFileSync).toHaveBeenCalledTimes(1);
    const writtenPath = (writeFileSync as ReturnType<typeof vi.fn>).mock.calls[0][0] as string;
    expect(writtenPath).toBe('/tmp/output/navigator.json');

    const writtenContent = (writeFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
    // The written content should be valid JSON
    expect(() => JSON.parse(writtenContent)).not.toThrow();
  });
});
